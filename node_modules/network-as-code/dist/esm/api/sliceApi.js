/**
 * Copyright 2024 Nokia
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { errorHandler, InvalidParameterError } from "../errors/index.js";
import fetch from "node-fetch";
export class SliceAPI {
    /**
 *  Methods takes rapidHost, rapidKey, and baseUrl.
 * Args:
            rapidHost (str): RapidAPI Host
            rapidKey (str): RapidAPI Key
            baseUrl (str): URL for
    */
    constructor(baseURL, rapidKey, rapidHost, agent) {
        this.baseUrl = baseURL;
        this.headers = {
            "X-RapidAPI-Host": rapidHost,
            "X-RapidAPI-Key": rapidKey,
            "content-type": "application/json",
        };
        this.agent = agent;
    }
    create(networkId_1, sliceInfo_1, notificationUrl_1, optionalArgs_1) {
        return __awaiter(this, arguments, void 0, function* (networkId, sliceInfo, notificationUrl, optionalArgs, modify = false) {
            const body = {
                networkIdentifier: networkId,
                sliceInfo: sliceInfo,
                notificationUrl: notificationUrl,
            };
            if (optionalArgs) {
                if (optionalArgs.name) {
                    body.name = optionalArgs.name;
                }
                if (optionalArgs.areaOfService) {
                    body.areaOfService = this.convertAreaOfServiceObj(optionalArgs.areaOfService);
                }
                if (optionalArgs.notificationAuthToken) {
                    body.notificationAuthToken = optionalArgs.notificationAuthToken;
                }
                if (optionalArgs.maxDataConnections) {
                    body.maxDataConnections = optionalArgs.maxDataConnections;
                }
                if (optionalArgs.maxDevices) {
                    body.maxDevices = optionalArgs.maxDevices;
                }
                if (optionalArgs.sliceDownlinkThroughput) {
                    body.sliceDownlinkThroughput =
                        optionalArgs.sliceDownlinkThroughput;
                }
                if (optionalArgs.sliceUplinkThroughput) {
                    body.sliceUplinkThroughput = optionalArgs.sliceUplinkThroughput;
                }
                if (optionalArgs.deviceDownlinkThroughput) {
                    body.deviceDownlinkThroughput =
                        optionalArgs.deviceDownlinkThroughput;
                }
                if (optionalArgs.deviceUplinkThroughput) {
                    body.deviceUplinkThroughput =
                        optionalArgs.deviceUplinkThroughput;
                }
            }
            let response;
            if (modify) {
                if (!(optionalArgs === null || optionalArgs === void 0 ? void 0 : optionalArgs.name)) {
                    throw new Error("Name is mandatory for modify");
                }
                response = yield fetch(`${this.baseUrl}/slices/${optionalArgs.name}`, {
                    method: "PUT",
                    headers: this.headers,
                    body: JSON.stringify(body),
                    agent: this.agent,
                });
                errorHandler(response);
                return yield response.json();
            }
            else {
                response = yield fetch(`${this.baseUrl}/slices`, {
                    method: "POST",
                    headers: this.headers,
                    body: JSON.stringify(body),
                    agent: this.agent,
                });
                errorHandler(response);
                return yield response.json();
            }
        });
    }
    getAll() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield fetch(`${this.baseUrl}/slices`, {
                method: "GET",
                headers: this.headers,
                agent: this.agent,
            });
            errorHandler(response);
            return response.json();
        });
    }
    get(sliceId) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield fetch(`${this.baseUrl}/slices/${sliceId}`, {
                method: "GET",
                headers: this.headers,
                agent: this.agent,
            });
            errorHandler(response);
            return response.json();
        });
    }
    activate(sliceId) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield fetch(`${this.baseUrl}/slices/${sliceId}/activate`, {
                method: "POST",
                headers: this.headers,
                agent: this.agent,
            });
            errorHandler(response);
            return response;
        });
    }
    deactivate(sliceId) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield fetch(`${this.baseUrl}/slices/${sliceId}/deactivate`, {
                method: "POST",
                headers: this.headers,
                agent: this.agent,
            });
            errorHandler(response);
            return response;
        });
    }
    delete(sliceId) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield fetch(`${this.baseUrl}/slices/${sliceId}`, {
                method: "DELETE",
                headers: this.headers,
                agent: this.agent,
            });
            errorHandler(response);
            return response;
        });
    }
    convertAreaOfServiceObj(areaOfService) {
        let polygon = [];
        areaOfService.polygon.forEach((point) => {
            polygon.push({ lat: point.latitude, lon: point.longitude });
        });
        return { polygon };
    }
}
export class AttachAPI {
    /**
 *  The class takes rapidHost, rapidKey, and baseUrl.
 * Args:
            rapidHost (str): RapidAPI Host
            rapidKey (str): RapidAPI Key
            baseUrl (str): URL for
    */
    constructor(baseURL, rapidKey, rapidHost, agent) {
        this.baseUrl = baseURL;
        this.headers = {
            "X-RapidAPI-Host": rapidHost,
            "X-RapidAPI-Key": rapidKey,
            "content-type": "application/json",
        };
        this.agent = agent;
    }
    attach(device, sliceId, notificationAuthToken, notificationUrl, trafficCategories) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!device.phoneNumber) {
                throw new InvalidParameterError("Device phone number is required.");
            }
            let payload = {
                device: {
                    phoneNumber: device.phoneNumber,
                },
                sliceId,
            };
            if (trafficCategories) {
                payload.trafficCategories = trafficCategories;
            }
            if (notificationUrl) {
                payload.webhook = {
                    notificationUrl,
                    notificationAuthToken,
                };
            }
            if (device.ipv4Address) {
                const ipv4Address = {};
                if (device.ipv4Address.publicAddress) {
                    ipv4Address.publicAddress = device.ipv4Address.publicAddress;
                }
                if (device.ipv4Address.privateAddress) {
                    ipv4Address.privateAddress = device.ipv4Address.privateAddress;
                }
                if (device.ipv4Address.publicPort) {
                    ipv4Address.publicPort = device.ipv4Address.publicPort;
                }
                if (Object.keys(ipv4Address).length > 0) {
                    payload.device.ipv4Address = ipv4Address;
                }
            }
            if (device.ipv6Address) {
                payload["device"]["ipv6Address"] = device.ipv6Address;
            }
            const res = yield fetch(`${this.baseUrl}/attachments`, {
                method: "POST",
                headers: this.headers,
                body: JSON.stringify(payload),
                agent: this.agent,
            });
            errorHandler(res);
            return yield res.json();
        });
    }
    detach(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield fetch(`${this.baseUrl}/attachments/${id}`, {
                method: "DELETE",
                headers: this.headers,
                agent: this.agent,
            });
            errorHandler(res);
        });
    }
    get(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield fetch(`${this.baseUrl}/attachments/${id}`, {
                method: "GET",
                headers: this.headers,
                agent: this.agent,
            });
            errorHandler(res);
            return yield res.json();
        });
    }
    getAttachments() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield fetch(`${this.baseUrl}/attachments`, {
                method: "GET",
                headers: this.headers,
                agent: this.agent,
            });
            errorHandler(res);
            return yield res.json();
        });
    }
}
