/**
 * Copyright 2024 Nokia
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { NotFoundError } from "../errors/index.js";
function fetchAndRemove(sliceAttachments, device) {
    for (let i = 0; i < sliceAttachments.length; i++) {
        const attachment = sliceAttachments[i];
        if (attachment.devicePhoneNumber === device.phoneNumber) {
            const attachmentId = attachment.attachmentId;
            sliceAttachments.splice(i, 1);
            return attachmentId;
        }
    }
    return null;
}
/**
 *  A class representing the `Slice` model.
 * #### Private Attributes:
       @param _api(APIClient): An API client object.
       @param _sessions(List[Session]): List of device session instances.
       @param _attachments(DeviceAttachment[]): List of device attachments

    #### Public Attributes:
       @param sid (optional): String ID of the slice
       @param state (str): State of the slice (ie. NOT_SUBMITTED)
       @param name (optional): Optional short name for the slice. Must be ASCII characters, digits and dash. Like name of an event, such as "Concert-2029-Big-Arena".
       @param networkIdentifier (NetworkIdentifier): Name of the network
       @param sliceInfo (SliceInfo): Purpose of this slice
       @param areaOfService (AreaOfService): Location of the slice
       @param maxDataConnections (optional): Optional maximum number of data connection sessions in the slice.
       @param maxDevices (optional): Optional maximum number of devices using the slice.
       @param sliceDownlinkThroughput (optional): Optional throughput object
       @param sliceUplinkThroughput (optional): Optional throughput object
       @param deviceDownlinkThroughput (optional): Optional throughput object
       @param deviceUplinkThroughput: (optional): Optional throughput object


    #### Public Methods:
        activate (None): Activate a network slice.
        attach (): Attach a network slice to a device.
        deactivate (None): Deactivate a network slice. The slice state must be active to be able to perform this operation.
        delete (None): Delete network slice. The slice state must not be active to perform this operation.
        refresh (None): Refresh the state of the network slice.

    #### Callback Functions:
        on_creation ():
        on_event ():
 */
export class Slice {
    constructor(api, state, sliceInfo, networkIdentifier, notificationUrl, sliceOptionalArgs) {
        this._api = api;
        this._sessions = [];
        this._attachments = [];
        this.state = state;
        this.sliceInfo = sliceInfo;
        this.networkIdentifier = networkIdentifier;
        this.notificationUrl = notificationUrl;
        if (sliceOptionalArgs) {
            const { sid, name, areaOfService, maxDataConnections, maxDevices, notificationAuthToken, sliceDownlinkThroughput, sliceUplinkThroughput, deviceDownlinkThroughput, deviceUplinkThroughput, } = sliceOptionalArgs;
            this.sid = sid;
            this.name = name;
            this.areaOfService = areaOfService;
            this.maxDataConnections = maxDataConnections;
            this.maxDevices = maxDevices;
            this.sliceDownlinkThroughput = sliceDownlinkThroughput;
            this.sliceUplinkThroughput = sliceUplinkThroughput;
            this.deviceDownlinkThroughput = deviceDownlinkThroughput;
            this.deviceUplinkThroughput = deviceUplinkThroughput;
            this.notificationAuthToken = notificationAuthToken;
        }
    }
    /**
 *  Activate network slice.
 * #### Args:
            None

    #### Example:
    slice.activate()
 */
    activate() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.name) {
                return yield this._api.slicing.activate(this.name);
            }
        });
    }
    /**
 *  Wait for an ongoing order to complete.
           I.e. not being in "PENDING" state.
           Returns new state.

        #### Args:
            desiredState(Optional|string): if not provided, the AVAILABLE state will be returned
            timeout (datetime.timedelta): Timeout of waiting. Default is 1h.
            pollBackoff (datetime.timedelta): Backoff time between polling.

        #### Example:
            ```TypeScript
            newState = slice.waitFor()
            ```
 */
    waitFor(desiredState_1) {
        return __awaiter(this, arguments, void 0, function* (desiredState, timeout = 3600 * 1000, pollBackoff = 10 * 1000) {
            if (!desiredState) {
                desiredState = "AVAILABLE";
            }
            const sleep = (ms) => new Promise((r) => setTimeout(r, ms));
            const end = Date.now() + timeout;
            while (this.state !== desiredState && Date.now() < end) {
                yield sleep(pollBackoff);
                yield this.refresh();
            }
            return this.state;
        });
    }
    /**
 *  Deactivate network slice.
 * #### Args:
            None

    #### Example:
    slice.deactivate()
 */
    deactivate() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.name) {
                return yield this._api.slicing.deactivate(this.name);
            }
        });
    }
    /**
 *  Modify the parameters for an existing slice.
 * #### Args:
        @param optionalArgs(SliceModifyOptionalArgs): properties of `SliceModifyOptionalArgs` object
        @example ```TypeScript
        slice.modify({
                sliceDownlinkThroughput: { guaranteed: 10, maximum: 10 },
                sliceUplinkThroughput: { guaranteed: 10, maximum: 10 },
                deviceDownlinkThroughput: { guaranteed: 10, maximum: 10 },
                deviceUplinkThroughput: { guaranteed: 10, maximum: 10 },
                maxDataConnections: 12,
                maxDevices: 3
        });
        ```
 */
    modify(_a) {
        return __awaiter(this, arguments, void 0, function* ({ sliceDownlinkThroughput, sliceUplinkThroughput, deviceDownlinkThroughput, deviceUplinkThroughput, maxDataConnections, maxDevices, }) {
            yield this._api.slicing.create(this.networkIdentifier, this.sliceInfo, this.notificationUrl, {
                notificationAuthToken: this.notificationAuthToken,
                name: this.name,
                areaOfService: this.areaOfService,
                sliceDownlinkThroughput: sliceDownlinkThroughput,
                sliceUplinkThroughput: sliceUplinkThroughput,
                deviceDownlinkThroughput: deviceDownlinkThroughput,
                deviceUplinkThroughput: deviceUplinkThroughput,
                maxDataConnections: maxDataConnections,
                maxDevices: maxDevices,
            }, true);
            // Update model (if no exception on modify)
            this.sliceDownlinkThroughput = sliceDownlinkThroughput;
            this.sliceUplinkThroughput = sliceUplinkThroughput;
            this.deviceDownlinkThroughput = deviceDownlinkThroughput;
            this.deviceUplinkThroughput = deviceUplinkThroughput;
            this.maxDataConnections = maxDataConnections;
            this.maxDevices = maxDevices;
        });
    }
    /**
 *  Delete network slice.
 * #### Args:
            None

    #### Example:
    slice.delete()
 */
    delete() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.name) {
                return yield this._api.slicing.delete(this.name);
            }
        });
    }
    /**
 *  Refresh state of the network slice.
 * #### Args:
            None

    #### Example:
    slice.refresh()
 */
    refresh() {
        return __awaiter(this, void 0, void 0, function* () {
            const sliceData = yield this._api.slicing.get(this.name);
            this.state = sliceData["state"];
        });
    }
    setAttachments(attachments) {
        if (attachments.length > 0) {
            this._attachments = [];
            attachments.forEach((attachment) => {
                this._attachments.push({
                    devicePhoneNumber: attachment.resource.device.phoneNumber,
                    attachmentId: attachment.nac_resource_id,
                });
            });
        }
    }
    /**
 *  Attach network slice.
 * #### Args:
            @param device (Device): Device object that the slice is being attached to
            @param notificationAuthToken (string): Authorization token for notification sending.
            @param notificationUrl (string): Notification URL for attachment-related events.
            @param trafficCategories (TrafficCategories): It should contain the OSId, according to the OS and the OsAppId

            @example```TypeScript
            device = client.devices.get("testuser@open5glab.net", {public_address="1.1.1.2", private_address="1.1.1.2", public_port=80})
            const new_attachment = await mySlice.attach(
                    device,
                    "replace-with-your-auth-token",
                    // Use HTTPS to send notifications
                    // about slice attachments.
                    "https://example.com/notifications",
                    {
                        apps: {
                            // This is the OS ID used by Android
                            os: "97a498e3-fc92-5c94-8986-0333d06e4e47",
                            apps: ["ENTERPRISE", "ENTERPRISE2"],
                        },
                    }
                );
            ```
    */
    attach(device, notificationAuthToken, notificationUrl, trafficCategories) {
        return __awaiter(this, void 0, void 0, function* () {
            const newAttachment = yield this._api.sliceAttach.attach(device, this.name, notificationAuthToken, notificationUrl, trafficCategories);
            this._attachments.push({
                attachmentId: newAttachment.nac_resource_id,
                devicePhoneNumber: device.phoneNumber,
            });
            return newAttachment;
        });
    }
    /**
 *  Detach network slice.
 * #### Args:
            @param device (Device): Device object that the slice is being attached to

            @example```TypeScript
                device = client.devices.get("testuser@open5glab.net", {public_address="1.1.1.2", private_address="1.1.1.2", public_port=80})
                slice.attach(device)
                slice.detach(device)
            ```
 */
    detach(device) {
        return __awaiter(this, void 0, void 0, function* () {
            const attachmentId = fetchAndRemove(this._attachments, device);
            if (attachmentId) {
                this._api.sliceAttach.detach(attachmentId);
            }
            else {
                throw new NotFoundError("Attachment not found");
            }
        });
    }
}
